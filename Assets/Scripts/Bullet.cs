using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Bullet : MonoBehaviour
{
    // Get the Cannon
    Cannon cannon;
    // Set the initial velocity
    float initialVelocity;
    // Set the unit vector
    public float vx, vy, ax, ay;
    // The angle of the cannon
    float angle;
    // Get the Terrain
    TerrainGenerator terrain;
    // Check if the bullet pass the airwall
    bool passAirWall;

    // Start is called before the first frame update
    void Start()
    {
        cannon = GameObject.FindObjectOfType<Cannon>();
        terrain = GameObject.FindObjectOfType<TerrainGenerator>();
        ax = 0f;
        initialVelocity = cannon.muzzle / 500f;
        // Modelling the gravity here
        ay = -0.00196f;
        angle = cannon.angle;
        // As the projectile motion we did in class
        vx = initialVelocity * Mathf.Cos(angle * Mathf.Deg2Rad);
        vy = initialVelocity * Mathf.Sin(angle * Mathf.Deg2Rad);
        passAirWall = false;
    }

    // Update is called once per frame
    void Update()
    {
        // Add the acceleration to each direction
        vx += ax;
        vy += ay;
        // Move the object to the new postion based on the new velocity
        gameObject.transform.position = new Vector3(transform.position.x - vx, transform.position.y + vy, 0);

        // Destroy if off screen
        if (OutOfBound())
        {
            Destroy(gameObject);
        }
        // Resolutions with collision to several textures
        CollideResolution();
        // Destroy if stop
        if (vx == 0 && vy == 0)
        {
            Destroy(gameObject);
        }
        // Check if pass to the left of Airwall
        if (gameObject.transform.position.x < 6)
        {
            passAirWall = true;
        }
        // Destroy if collide with air wall from left
        if (passAirWall && gameObject.transform.position.x >= 6)
        {
            Destroy(gameObject);
        }
        // Handle the bullet collision
        BulletCollision();
    }
    // Check if the bullet is out of bound
    // Acutally it's weired to destroy if the bullet off the upper bound, since it should fall down anyway....
    // But I just simply follow the instruction of the assignment here....
    bool OutOfBound()
    {
        bool x = transform.position.x > 10.5f || transform.position.x < -10.5f;
        bool y = transform.position.y > 5.3f || transform.position.y < -5.3f;
        return x || y;
    }
    // Check if the bullet touch the terrain
    float CollideTerrainDetection()
    {
        float radius1 = gameObject.GetComponent<SpriteRenderer>().bounds.size.x / 2;
        float radius2 = terrain.point.GetComponent<SpriteRenderer>().bounds.size.x / 2;
        float sum;
        float distance;
        // Since the terrain in generated by many points
        // The idea here is to do the two cycles collision detection as we did in class
        // Check if the distance between two centers is smaller than the sum of radius
        for (int i = 0; i < terrain.index; i++)
        {
            sum = Mathf.Pow(terrain.terrain[i].x - transform.position.x, 2) + Mathf.Pow(terrain.terrain[i].y - transform.position.y, 2);
            distance = Mathf.Sqrt(sum);
            if (distance <= radius1 + radius2)
            {
                return terrain.terrain[i].x;
            }
        }
        // If there is no collision, return -100 as a signal
        return -100f;
    }
    // To handle all different situation
    void CollideResolution()
    {
        float posX = CollideTerrainDetection();
        // Handle collision with ground
        if ((posX > -8.44f && posX < -4) || posX > 4)
        {
            vy *= -0.8f;
            vx *= 0.8f;
        }
        // Handle collision with the left vertical wall
        else if (transform.position.x < -8.44f)
        {
            vy *= -0.8f;
            vx *= -0.8f;
        }
        // Handle collision with montain
        else if (posX <= 4 && posX >= -4)
        {
            vy *= -0.8f;
            vx *= -0.8f;
        }
        // If the velocity is small enough, just stop it and destroy
        if (Mathf.Abs(vy) < 0.00196f && posX != -100f)
        {
            vy = 0;
            ay = 0;
        }

        if (Mathf.Abs(vx) < 0.00196f && posX != -100f)
        {
            vx = 0;
        }
    }
    // Handle the collision between two bullets
    void BulletCollision()
    {
        // Get all bullets
        GameObject[] bullets = GameObject.FindGameObjectsWithTag("Bullet");
        // Don't divide by 2 here, since the radius of two bullets are same
        float radius = gameObject.GetComponent<SpriteRenderer>().bounds.size.x;
        Bullet b = null;
        float sum;
        float distance;
        for (int i = 0; i < bullets.Length; i++)
        {
            // Don't do the collision detection with itself
            if (!gameObject.Equals(bullets[i]))
            {
                sum = Mathf.Pow(bullets[i].transform.position.x - gameObject.transform.position.x, 2) + Mathf.Pow(bullets[i].transform.position.y - gameObject.transform.position.y, 2);
                distance = Mathf.Sqrt(sum);
                // Check by the two circles collision detection
                if (distance <= radius)
                {
                    b = bullets[i].GetComponent<Bullet>();
                    // by the law of Conservation of momentum, and we assume all bullets have same mass, so just exchange their velocities
                    float tmpVx = vx;
                    float tmpVy = vy;
                    vx = b.vx;
                    vy = b.vy;
                    b.vx = tmpVx;
                    b.vy = tmpVy;
                }
            }
        }
    }
}
